import { keyBy, ScalarTypeTable, keyBy2 } from './utils/common';
export class DMMFClass {
    constructor({ datamodel, schema, mappings }) {
        this.outputTypeToMergedOutputType = (outputType) => {
            const model = this.modelMap[outputType.name];
            return {
                ...outputType,
                isEmbedded: model ? model.isEmbedded : false,
                fields: outputType.fields,
            };
        };
        this.datamodel = datamodel;
        this.schema = schema;
        this.mappings = mappings;
        this.enumMap = this.getEnumMap();
        this.datamodelEnumMap = this.getDatamodelEnumMap();
        this.queryType = this.getQueryType();
        this.mutationType = this.getMutationType();
        this.modelMap = this.getModelMap();
        this.outputTypes = this.getOutputTypes();
        this.outputTypeMap = this.getMergedOutputTypeMap();
        this.resolveOutputTypes();
        this.inputObjectTypes = this.schema.inputObjectTypes;
        this.inputTypeMap = this.getInputTypeMap();
        this.resolveInputTypes();
        this.resolveFieldArgumentTypes();
        this.mappingsMap = this.getMappingsMap();
        // needed as references are not kept
        this.queryType = this.outputTypeMap.Query;
        this.mutationType = this.outputTypeMap.Mutation;
        this.rootFieldMap = this.getRootFieldMap();
    }
    get [Symbol.toStringTag]() {
        return 'DMMFClass';
    }
    resolveOutputTypes() {
        for (const type of this.outputTypes.model) {
            for (const field of type.fields) {
                if (typeof field.outputType.type === 'string' &&
                    !ScalarTypeTable[field.outputType.type]) {
                    field.outputType.type =
                        this.outputTypeMap[field.outputType.type] ||
                            this.outputTypeMap[field.outputType.type] ||
                            this.enumMap[field.outputType.type] ||
                            field.outputType.type;
                }
            }
            type.fieldMap = keyBy(type.fields, 'name');
        }
        for (const type of this.outputTypes.prisma) {
            for (const field of type.fields) {
                if (typeof field.outputType.type === 'string' &&
                    !ScalarTypeTable[field.outputType.type]) {
                    field.outputType.type =
                        this.outputTypeMap[field.outputType.type] ||
                            this.outputTypeMap[field.outputType.type] ||
                            this.enumMap[field.outputType.type] ||
                            field.outputType.type;
                }
            }
            type.fieldMap = keyBy(type.fields, 'name');
        }
    }
    resolveInputTypes() {
        const inputTypes = this.inputObjectTypes.prisma;
        if (this.inputObjectTypes.model) {
            inputTypes.push(...this.inputObjectTypes.model);
        }
        for (const type of inputTypes) {
            for (const field of type.fields) {
                for (const fieldInputType of field.inputTypes) {
                    const fieldType = fieldInputType.type;
                    if (typeof fieldType === 'string' &&
                        !ScalarTypeTable[fieldType] &&
                        (this.inputTypeMap[fieldType] || this.enumMap[fieldType])) {
                        fieldInputType.type =
                            this.inputTypeMap[fieldType] ||
                                this.enumMap[fieldType] ||
                                fieldType;
                    }
                }
            }
            type.fieldMap = keyBy(type.fields, 'name');
        }
    }
    resolveFieldArgumentTypes() {
        for (const type of this.outputTypes.prisma) {
            for (const field of type.fields) {
                for (const arg of field.args) {
                    for (const argInputType of arg.inputTypes) {
                        const argType = argInputType.type;
                        if (typeof argType === 'string' && !ScalarTypeTable[argType]) {
                            argInputType.type =
                                this.inputTypeMap[argType] || this.enumMap[argType] || argType;
                        }
                    }
                }
            }
        }
        for (const type of this.outputTypes.model) {
            for (const field of type.fields) {
                for (const arg of field.args) {
                    for (const argInputType of arg.inputTypes) {
                        const argType = argInputType.type;
                        if (typeof argType === 'string' && !ScalarTypeTable[argType]) {
                            argInputType.type =
                                this.inputTypeMap[argType] ||
                                    this.enumMap[argType] ||
                                    argInputType.type;
                        }
                    }
                }
            }
        }
    }
    getQueryType() {
        return this.schema.outputObjectTypes.prisma.find((t) => t.name === 'Query');
    }
    getMutationType() {
        return this.schema.outputObjectTypes.prisma.find((t) => t.name === 'Mutation');
    }
    getOutputTypes() {
        return {
            model: this.schema.outputObjectTypes.model.map(this.outputTypeToMergedOutputType),
            prisma: this.schema.outputObjectTypes.prisma.map(this.outputTypeToMergedOutputType),
        };
    }
    getDatamodelEnumMap() {
        return keyBy(this.datamodel.enums, 'name');
    }
    getEnumMap() {
        return {
            ...keyBy(this.schema.enumTypes.prisma, 'name'),
            ...(this.schema.enumTypes.model
                ? keyBy(this.schema.enumTypes.model, 'name')
                : undefined),
        };
    }
    getModelMap() {
        return keyBy(this.datamodel.models, 'name');
    }
    getMergedOutputTypeMap() {
        return {
            ...keyBy(this.outputTypes.model, 'name'),
            ...keyBy(this.outputTypes.prisma, 'name'),
        };
    }
    getInputTypeMap() {
        return {
            ...(this.schema.inputObjectTypes.model
                ? keyBy(this.schema.inputObjectTypes.model, 'name')
                : undefined),
            ...keyBy(this.schema.inputObjectTypes.prisma, 'name'),
        };
    }
    getMappingsMap() {
        return keyBy(this.mappings.modelOperations, 'model');
    }
    getRootFieldMap() {
        return keyBy2(this.queryType.fields, this.mutationType.fields, 'name');
    }
}
//# sourceMappingURL=dmmf.js.map