export class Dataloader {
    constructor(options) {
        this.options = options;
        this.tickActive = false;
        this.batches = {};
    }
    get [Symbol.toStringTag]() {
        return 'Dataloader';
    }
    request(request) {
        const hash = this.options.batchBy(request);
        if (!hash) {
            return this.options.singleLoader(request);
        }
        if (!this.batches[hash]) {
            this.batches[hash] = [];
            // make sure, that we only tick once at a time
            if (!this.tickActive) {
                this.tickActive = true;
                process.nextTick(() => {
                    this.dispatchBatches();
                    this.tickActive = false;
                });
            }
        }
        return new Promise((resolve, reject) => {
            this.batches[hash].push({
                request,
                resolve,
                reject,
            });
        });
    }
    dispatchBatches() {
        for (const key in this.batches) {
            const batch = this.batches[key];
            delete this.batches[key];
            // only batch if necessary
            // this might occur, if there's e.g. only 1 findUnique in the batch
            if (batch.length === 1) {
                this.options
                    .singleLoader(batch[0].request)
                    .then((result) => {
                    if (result instanceof Error) {
                        batch[0].reject(result);
                    }
                    else {
                        batch[0].resolve(result);
                    }
                })
                    .catch((e) => {
                    batch[0].reject(e);
                });
            }
            else {
                this.options
                    .batchLoader(batch.map((j) => j.request))
                    .then((results) => {
                    if (results instanceof Error) {
                        for (let i = 0; i < batch.length; i++) {
                            batch[i].reject(results);
                        }
                    }
                    else {
                        for (let i = 0; i < batch.length; i++) {
                            const value = results[i];
                            if (value instanceof Error) {
                                batch[i].reject(value);
                            }
                            else {
                                batch[i].resolve(value);
                            }
                        }
                    }
                })
                    .catch((e) => {
                    for (let i = 0; i < batch.length; i++) {
                        batch[i].reject(e);
                    }
                });
            }
        }
    }
}
//# sourceMappingURL=Dataloader.js.map